{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"SCADA-Based Reliability Evaluation\"\n",
        "subtitle: \"Kelmarsh Wind Farm - 12.3 MW\"\n",
        "author: \"Jorge A. Thomas\"\n",
        "date: 23.April.2025\n",
        "format:    \n",
        "    html:\n",
        "      theme: default\n",
        "      self-contained: true\n",
        "      code-fold: true\n",
        "      df-print: tibble\n",
        "      code-summary: \"Show the code\"\n",
        "      toc: true\n",
        "      toc-depth: 2\n",
        "      grid: \n",
        "        margin-width: 350px      \n",
        "execute: \n",
        "  echo: false\n",
        "reference-location: margin \n",
        "citation-location: document\n",
        "bibliography: references.bib\n",
        "nocite: '@*'\n",
        "---\n",
        "\n",
        "\n",
        "## Kelmarsh Wind Farm\n",
        "\n",
        "### Project Overview\n",
        "\n",
        "\"Kelmarsh comprises six 2.05MW Senvion MM92 turbines. The Project was acquired from EON in December 2014 and was constructed in joint venture with Santander using balance sheet finance. Construction was completed in April 2016. It is now owned by Cubico Investments.\"\n",
        "\n",
        "- [https://www.blue-energyco.com/our-projects/kelmarsh/](https://www.blue-energyco.com/our-projects/kelmarsh/)  \n",
        "\n",
        "::: {#fig-intro layout-ncol=\"2\"}\n",
        "![(a) Kelmarsh Wind Farm](./online_assets/Kelmarsh_wind_project_blue-energyco.jpg){width=\"98%\"}\n",
        "\n",
        "![(b) Senvion MM92 turbine](./online_assets/turbine-senvion_mm92.jpg){width=\"98%\"}\n",
        "\n",
        "Kelmarsh Wind Farm is located near Haselbach, Northamptonshire, UK.\n",
        ":::\n"
      ],
      "id": "fbc9a42b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Pyhton-setup\n",
        "#| eval: true\n",
        "#| echo: false\n",
        "\n",
        "# https://en.wind-turbine-models.com/turbines/889-senvion-mm92\n",
        "# https://www.thewindpower.net/windfarm_en_17507_kelmarsh.php\n",
        "\n",
        "# Plumley, C. (2022). Penmanshiel wind farm data (0.1.0) [Kelmarsh dataset]\n",
        "# Cubico Sustainable Investments\n",
        "\n",
        "from pathlib import Path\n",
        "import duckdb\n",
        "import polars as pl\n",
        "import polars.selectors as cs\n",
        "import plotly.express as px\n",
        "from great_tables import GT, md, style, loc\n",
        "\n",
        "fpath_processed = \"../data/processed/\"\n",
        "fpath_interim = \"../data/interim/\"\n",
        "fpath_online = \"./online_assets/\""
      ],
      "id": "Pyhton-setup",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Read-Data\n",
        "#| eval: true\n",
        "\n",
        "tstatus = pl.read_parquet(f\"{fpath_online}Kelmarsh_Turbines_Status_20160114_20230109_n385133_cols12.parquet\")"
      ],
      "id": "Read-Data",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Events Catalogue and Status\n"
      ],
      "id": "5697501d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Events-Catalogue\n",
        "#| eval: true\n",
        "#| warning: true\n",
        "\n",
        "events_catalogue = (\n",
        "    tstatus.group_by(\"IEC category\", \"Status\")\n",
        "    .agg(pl.len().alias(\"Count\"))    \n",
        "    .pivot(\n",
        "        values=\"Count\",\n",
        "        index=\"IEC category\",\n",
        "        on=\"Status\"\n",
        "    )\n",
        "    .fill_null(0)\n",
        ")\n",
        "\n",
        "GT(events_catalogue).tab_source_note(source_note='Note: Only \"Forced outage\" events with status \"Stop\" are considered for the evaluation, i.e., 892 events.')"
      ],
      "id": "Events-Catalogue",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Filter-Stops\n",
        "#| eval: true\n",
        "\n",
        "null_stop_events = pl.sql(    \n",
        "    \"\"\"\n",
        "    SELECT * EXCLUDE (\"Custom contract category\")    \n",
        "    FROM tstatus\n",
        "    WHERE \"IEC category\" IS NULL AND \"Status\" = 'Stop'\n",
        "\n",
        "    \"\"\").collect()\n",
        "\n",
        "# null_stop_events['Status'].unique()\n",
        "\n",
        "curtailment = pl.sql(    \n",
        "    \"\"\"\n",
        "    SELECT * EXCLUDE (\"Custom contract category\")    \n",
        "    FROM tstatus\n",
        "    WHERE \"Status\" = 'Curtailment'\n",
        "    \"\"\").collect()\n",
        "\n",
        "\n",
        "stops = pl.sql(    \n",
        "    \"\"\"\n",
        "    SELECT * EXCLUDE (\"Custom contract category\")    \n",
        "    FROM tstatus\n",
        "    WHERE \"Status\" = 'Stop'\n",
        "    \"\"\").collect()\n",
        "\n",
        "# stops.group_by('IEC category').agg(pl.len().alias(\"Stop Events\"))"
      ],
      "id": "Filter-Stops",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Filter-Forced-Outages\n",
        "#| eval: true\n",
        "\n",
        "# Aggregate tables using SQL syntax\n",
        "\n",
        "foutages = pl.sql(\n",
        "    \"\"\"\n",
        "    SELECT * \n",
        "    FROM stops\n",
        "    WHERE \"IEC category\" = 'Forced outage' \n",
        "    \"\"\").collect()\n",
        "\n",
        "foutages = foutages.rename({\"Duration\":\"TTR\"})\n",
        "\n",
        "# TTF\n",
        "foutages = foutages.with_columns(\n",
        "    (pl.col(\"Timestamp start\").shift(-1) - pl.col(\"Timestamp end\")).shift(1).alias(\"TTF\")\n",
        "    )\n",
        "\n",
        "foutages = foutages.with_columns(\n",
        "    pl.when(pl.col(\"TTF\") < 0).then(None).otherwise(pl.col(\"TTF\")).alias(\"TTF\")\n",
        ")"
      ],
      "id": "Filter-Forced-Outages",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: write-foutages-online\n",
        "#| eval: false\n",
        "\n",
        "# foutages.write_parquet(f\"{fpath_online}/{\"Kelmarsh_Turbines_ForcedOutages_20160114_20230109_n892_cols12.parquet\"}\")"
      ],
      "id": "write-foutages-online",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: read-filtered-fo\n",
        "#| eval: false\n",
        "\n",
        "# foutages = pl.read_parquet(\"./online_assets/Kelmarsh_Turbines_ForcedOutages_20160114_20230109_n892_cols12.parquet\")\n",
        "\n",
        "# foutages"
      ],
      "id": "read-filtered-fo",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Binary-Plot\n",
        "#| eval: true\n",
        "\n",
        "# Generate data frame with 0-1 states\n",
        "\n",
        "dtstarts = foutages.select([\"Timestamp start\", \"Status\", \"Message\",  \"wt\"]).rename({\"Timestamp start\": \"Timestamp\"})\n",
        "\n",
        "dtends = foutages.select([\"Timestamp end\", \"Status\", \"Message\",  \"wt\"]).with_columns(pl.lit(\"Start\").alias(\"Status\")).rename({\"Timestamp end\": \"Timestamp\"})\n",
        "\n",
        "# Vertical concatenation\n",
        "tstates = pl.concat([dtstarts, dtends]).sort([\"wt\", 'Timestamp'])\n",
        "\n",
        "tstates= tstates.with_columns(\n",
        "    pl.when(pl.col(\"Status\") == \"Stop\").then(0).otherwise(1).alias(\"State\"),\n",
        "    pl.col(\"Timestamp\").dt.year().alias(\"Year\")    \n",
        "    )\n",
        "\n",
        "# Extract last year \n",
        "last_year = tstates[\"Year\"].unique().max()\n",
        "\n",
        "tstates= tstates.sort([\"Year\", \"wt\", \"Timestamp\"]).drop_nulls()"
      ],
      "id": "Binary-Plot",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: e-o-y-algo\n",
        "\n",
        "# TTF (or TTR) censoring  algorithm per Turbine per year.\n",
        "\n",
        "# ---- 1) Id  last row per year per wt\n",
        "\n",
        "last_rows = tstates.group_by([\"Year\", \"wt\"]).last().sort(\"Year\")\n",
        "\n",
        "# ---- 2) Create new rows with the same (last seen) State\n",
        "\n",
        "# This closes the year apporaching from the left \n",
        "\n",
        "last_rows = last_rows.with_columns(    \n",
        "    pl.col(\"Timestamp\").dt.truncate(\"1y\").dt.offset_by(\"1y\").dt.offset_by(\"-1s\").alias(\"Timestamp\"),  # Ceil timestamp\n",
        "    pl.lit(\"Last-seen-Censored\").alias(\"Message\")\n",
        "    )\n",
        "\n",
        "# ---- 3) Create first row df from last_rows df\n",
        "\n",
        "first_rows = last_rows.with_columns(\n",
        "     pl.col(\"Timestamp\").dt.offset_by('1s').alias(\"Timestamp\")\n",
        ")\n",
        "\n",
        "# ---- 4) df with new rows to be added\n",
        "\n",
        "new_censored_rows = pl.concat([first_rows, last_rows])\n",
        "\n",
        "# Add Year columns\n",
        "new_censored_rows = new_censored_rows.with_columns(\n",
        "    pl.col(\"Timestamp\").dt.year().alias(\"Year\")    \n",
        ")\n",
        "\n",
        "# Recompute Year_wt\n",
        "# new_censored_rows = new_censored_rows.with_columns(   \n",
        "#     (pl.col(\"Year\").cast(str) + \"-\" + pl.col(\"wt\")).alias(\"Year_wt\")\n",
        "# )\n",
        "\n",
        "# ---- 5) Add new rows to close tstates\n",
        "\n",
        "new_censored_rows = new_censored_rows.select(tstates.columns)  \n",
        "\n",
        "# reorder rows\n",
        "tstates = pl.concat([tstates, new_censored_rows]).sort([\"wt\", \"Timestamp\"])\n",
        "\n",
        "# ---- 6) Drop columns Year > 2022  \n",
        "tstates = tstates.filter(pl.col(\"Year\") <= last_year)"
      ],
      "id": "e-o-y-algo",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Find-Missing-Values\n",
        "#| eval: false\n",
        "\n",
        "# Get rows containing any null values\n",
        "missing = (tstates\n",
        "          .with_row_count(\"row_index\")\n",
        "          .filter(pl.any_horizontal(pl.all().is_null()))\n",
        "          .sort(\"row_index\"))\n",
        "\n",
        "# Display rows with missing values\n",
        "print(\"Rows containing missing values:\")\n",
        "print(missing)\n",
        "\n",
        "# Get count of missing values per column\n",
        "print(\"\\nMissing value counts per column:\")\n",
        "print(tstates.null_count())"
      ],
      "id": "Find-Missing-Values",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Square-Signal-Plot\n",
        "#| eval: false\n",
        "\n",
        "# Other line_shape options, or interpolation methods between given points:\n",
        "\n",
        "# 'hv' step ends, equivalent to pyplot's post option;\n",
        "# 'vh' step starts;\n",
        "# 'hvh' step middles, x axis;\n",
        "# 'vhv' step middles, y axis;\n",
        "# 'spline' smooth curve between points;\n",
        "# 'linear' line segments between points, default value for line_shape.\n",
        "\n",
        "fig = px.line(tstates,\n",
        "              x='Timestamp', \n",
        "              y=\"State\", \n",
        "              line_shape='hv', \n",
        "              facet_row=\"Year_wt\",\n",
        "              color=\"wt\",\n",
        "              hover_data=[\"Timestamp\", \"Message\", \"Status\"],  # Add the variables you want in tooltip\n",
        "              title=\"Time / State Diagram for Kellmarsh Wind Turbines (2016-2022)\",\n",
        "              subtitle= \"Step-down = Forced outage (IEC); Step-up=Start\",\n",
        "              labels={\"Timestamp\": \"UTC\", \"State\": \"\", \"wt\": \"\"}, \n",
        "              facet_row_spacing=0.01\n",
        "              )\n",
        "# Adjust spacing between facets\n",
        "fig.update_layout(\n",
        "    height=1200,  # Increase overall height\n",
        "    width=800,   # Set overall width\n",
        "    margin=dict(l=100, r=50, t=100, b=50),  # Adjust margins\n",
        "    showlegend=False,\n",
        "    legend=dict(orientation=\"h\",\n",
        "                yanchor=\"bottom\",\n",
        "                y=1.01,\n",
        "                xanchor=\"right\",\n",
        "                x=1,\n",
        "                font=dict(size=8),  # Reduce legend font size\n",
        "                itemsizing='constant',  # Make legend items more compact\n",
        "                itemwidth=30  # Reduce width of legend items\n",
        "                )                \n",
        ")\n",
        "\n",
        "# Update y-axis to show only 0 and 1 as labels\n",
        "fig.update_yaxes(\n",
        "    tickvals=[0, 1],  # Set tick values to 0 and 1\n",
        "    ticktext=[\"\", \"\"]  # Optional: Explicitly set tick text\n",
        ")\n",
        "\n",
        "fig.update_xaxes(matches=None, \n",
        "tickformat=\"%b\",\n",
        "showgrid=True\n",
        ")\n",
        "\n",
        "# Update facet labels orientation and size\n",
        "fig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1], textangle=0, xanchor='left', x=-0.08))  # labels horizontal\n",
        "fig.update_annotations(font_size=9)  # Reduce font size\n",
        "\n",
        "fig.show()"
      ],
      "id": "Square-Signal-Plot",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Time-State-Plot-By-Year\n",
        "\n",
        "# Get unique years\n",
        "years = tstates[\"Year\"].unique().sort()\n",
        "\n",
        "# Create a plot for each year\n",
        "pl_time_state = []\n",
        "for year in years:\n",
        "    # Filter data for current year\n",
        "    year_data = tstates.filter(pl.col(\"Year\") == year)\n",
        "    \n",
        "    fig = px.line(year_data,\n",
        "                  x='Timestamp', \n",
        "                  y=\"State\", \n",
        "                  line_shape='hv', \n",
        "                  facet_row=\"wt\",\n",
        "                  color=\"wt\",\n",
        "                  hover_data=[\"Message\", \"Status\"],\n",
        "                  title=\"Step-down: Forced outage (IEC) | Step-up: Start\",\n",
        "                  #subtitle= \"(0) Down Step=Forced outage (IEC), (1) Up Step=Start\",\n",
        "                  labels={\"Timestamp\": \"UTC\", \"State\": \"\", \"wt\": \"\"}, \n",
        "                  facet_row_spacing=0.01\n",
        "                  )\n",
        "    # Update layout\n",
        "    fig.update_layout(\n",
        "        height=700,\n",
        "        width=700,\n",
        "        margin=dict(l=100, r=50, t=100, b=50),\n",
        "        showlegend=False,\n",
        "        legend=dict(orientation=\"h\",\n",
        "                    yanchor=\"bottom\",\n",
        "                    y=1.01,\n",
        "                    xanchor=\"right\",\n",
        "                    x=1,\n",
        "                    font=dict(size=8),\n",
        "                    itemsizing='constant',\n",
        "                    itemwidth=30\n",
        "                    )                \n",
        "    )\n",
        "    # Update axes\n",
        "    fig.update_yaxes(\n",
        "        tickvals=[0, 1],\n",
        "        ticktext=[\"\", \"\"]\n",
        "    )\n",
        "    fig.update_xaxes(\n",
        "        matches='x',\n",
        "        tickformat=\"%b\",\n",
        "        dtick=\"M1\",  # Show ticks every month\n",
        "        showgrid=True\n",
        "    )\n",
        "    # Update facet labels\n",
        "    fig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1], \n",
        "                                               textangle=0, \n",
        "                                               xanchor='left', \n",
        "                                               x=-0.05))\n",
        "    fig.update_annotations(font_size=10)\n",
        "    pl_time_state.append(fig)\n",
        "\n",
        "# End of loop"
      ],
      "id": "Time-State-Plot-By-Year",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: calc-durations\n",
        "#| eval: true\n",
        "\n",
        "tstates_dur = tstates.with_columns(\n",
        "    (pl.col(\"Timestamp\").diff().dt.total_seconds()/3_600).alias(\"Duration\").shift(-1)\n",
        ")\n",
        "\n",
        "# CENSOR data around years transitions\n",
        "\n",
        "tstates_dur = tstates_dur.with_columns(\n",
        "    pl.when((pl.col(\"Duration\") <= 0) | (pl.col(\"Message\") ==\"Last-seen-Censored\"))\n",
        "    .then(None)\n",
        "    .otherwise(pl.col(\"Duration\"))\n",
        "    .alias(\"Duration\")    \n",
        ")\n",
        "\n",
        "tstates_dur =  tstates_dur.drop_nulls()\n",
        "\n",
        "# # Get each year duration\n",
        "# year_durations = tstates_dur.group_by(\"Year\").agg(\n",
        "#     pl.col(\"Timestamp\").max().alias(\"year_end\"),\n",
        "#     pl.col(\"Timestamp\").min().alias(\"year_start\")\n",
        "# ).with_columns(\n",
        "#     (pl.col(\"year_end\") - pl.col(\"year_start\")).dt.total_seconds().alias(\"duration_sec\")\n",
        "# ).sort(\"Year\")\n",
        "\n",
        "# year_durations = year_durations.with_columns(\n",
        "#     (pl.col(\"duration_sec\")/3_600).round(2).alias(\"duration_hours\")\n",
        "# ).drop(\"duration_sec\")\n",
        "\n",
        "tstates_dur = tstates_dur.rename({\"wt\": \"Turbine\"}).drop_nulls()\n",
        "tstates_dur = tstates_dur.sort([\"Turbine\", \"Timestamp\"])"
      ],
      "id": "calc-durations",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: calc-mttf-mttr\n",
        "\n",
        "ttf = tstates_dur.filter(pl.col(\"State\") == 1).rename({\"Duration\": \"TTF\"})\n",
        "\n",
        "ttf_agg_year = (    \n",
        "    ttf.group_by([\"Year\",  \"Turbine\"])\n",
        "    .agg(\n",
        "        pl.len().alias(\"State delete\"),                \n",
        "        pl.sum(\"TTF\").alias(\"Time to Failure\"),\n",
        "        pl.mean(\"TTF\").alias(\"MTTF\")               \n",
        "        )         \n",
        "    .sort([\"Year\",  \"Turbine\"])     \n",
        "    )\n",
        "\n",
        "ttr = tstates_dur.filter(pl.col(\"State\") == 0).rename({\"Duration\": \"TTR\"})\n",
        "\n",
        "ttr_agg_year = (    \n",
        "    ttr.group_by([\"Year\",  \"Turbine\"])\n",
        "    .agg(\n",
        "        pl.len().alias(\"Forced Outages\"),                \n",
        "        pl.sum(\"TTR\").alias(\"TTR\"),\n",
        "        pl.mean(\"TTR\").alias(\"MTTR\")                      \n",
        "        )    \n",
        "    .sort([\"Year\",  \"Turbine\"])      \n",
        "    )"
      ],
      "id": "calc-mttf-mttr",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: save-ttf-ttr\n",
        "#| eval: false\n",
        "\n",
        "# metadata for filename\n",
        "\n",
        "first_ts = ttr[\"Year\"].min()\n",
        "last_ts = ttr[\"Year\"].max()\n",
        "\n",
        "# Additional metadata options\n",
        "# null_pct = int(rel_param[\"MTTF\"].null_count() / len(silistea) * 100)\n",
        "\n",
        "filename_ttf = f\"Kelmarsh_time-to-failure_{first_ts}_{last_ts}_n{len(ttf)}_cols{len(ttf.columns)}.parquet\"\n",
        "\n",
        "# Save processed dataset\n",
        "ttf.write_parquet(f\"{fpath_processed}{filename_ttf}\")\n",
        "\n",
        "filename_ttr = f\"Kelmarsh_time-to-repair_{first_ts}_{last_ts}_n{len(ttr)}_cols{len(ttr.columns)}.parquet\"\n",
        "\n",
        "# Save processed dataset\n",
        "ttr.write_parquet(f\"{fpath_processed}{filename_ttr}\")"
      ],
      "id": "save-ttf-ttr",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: calc-outages-month\n",
        "#| eval: true\n",
        "\n",
        "monthly_outages = ttr.with_columns(\n",
        "    pl.col(\"Timestamp\").dt.month().alias(\"Month\")\n",
        ")\n",
        "\n",
        "monthly_outages = (\n",
        "    monthly_outages.group_by([\"Year\", \"Turbine\", \"Month\"])\n",
        "    .agg(pl.len().alias(\"Outages\"))\n",
        "    .sort([\"Year\", \"Turbine\", \"Month\"])\n",
        "    )\n",
        "\n",
        "monthly_outages_piv = monthly_outages.pivot(\n",
        "        values=\"Outages\",\n",
        "        index=[\"Year\", \"Turbine\"],\n",
        "        on=\"Month\",\n",
        "        aggregate_function=\"first\"\n",
        "    ).fill_null(strategy=\"zero\")\n",
        "\n",
        "monthly_outages_piv = monthly_outages_piv.select(\n",
        "    [\"Year\", \"Turbine\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]).sort(\"Year\", \"Turbine\")\n",
        "\n",
        "monthly_outages_ = monthly_outages_piv.with_columns(\n",
        "    pl.concat_list(pl.all().exclude(\"Year\", \"Turbine\")).alias(\"Monthly\")\n",
        "    ).select([\"Year\", \"Turbine\", \"Monthly\"])"
      ],
      "id": "calc-outages-month",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: calc-reliablity-params\n",
        "#| eval: true\n",
        "\n",
        "rel_param = ttf_agg_year.join(ttr_agg_year, on=[\"Year\", \"Turbine\"], how=\"left\")\n",
        "rel_param = rel_param.join(monthly_outages_, on=[\"Year\", \"Turbine\"])\n",
        "rel_param = rel_param.drop(\"State delete\")\n",
        "rel_param = rel_param.rename({\"TTR\":\"Downtime\", \"Time to Failure\": \"Uptime\"})\n",
        "\n",
        "rel_param = rel_param.with_columns(\n",
        "    (pl.col(\"Uptime\") + pl.col(\"Downtime\")).alias(\"EvalTime\")\n",
        ")\n",
        "\n",
        "rel_param = rel_param.with_columns(\n",
        "    (pl.col(\"Forced Outages\")/pl.col(\"EvalTime\")).alias(\"Failure Rate\"),\n",
        "    (pl.col(\"MTTR\")/(pl.col(\"MTTF\") + pl.col(\"MTTR\"))).alias(\"FOR\"),    \n",
        ")\n",
        "\n",
        "rel_param = rel_param.with_columns(    \n",
        "    (1-pl.col(\"FOR\")).alias(\"Availability\"),\n",
        "    pl.lit(\"wind-turbine-icon-10.jpg\").alias(\"icon\")\n",
        ")"
      ],
      "id": "calc-reliablity-params",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: write-rel-eval-results\n",
        "#| eval: false\n",
        "\n",
        "# metadata for filename\n",
        "\n",
        "first_ts = rel_param[\"Year\"].min()\n",
        "last_ts = rel_param[\"Year\"].max()\n",
        "\n",
        "# Additional metadata options\n",
        "# null_pct = int(rel_param[\"MTTF\"].null_count() / len(silistea) * 100)\n",
        "\n",
        "filename = f\"Kelmarsh_reliability_paramaters_{first_ts}_{last_ts}_n{len(rel_param)}_cols{len(rel_param.columns)}.parquet\"\n",
        "\n",
        "# Save processed dataset\n",
        "rel_param.write_parquet(f\"{fpath_processed}{filename}\")"
      ],
      "id": "write-rel-eval-results",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: generate-table\n",
        "#| eval: true\n",
        "\n",
        "gt_reliability = (\n",
        "    GT(rel_param,\n",
        "    rowname_col = \"Turbine\",\n",
        "    groupname_col=\"Year\"\n",
        "    )\n",
        "    .opt_vertical_padding(scale=0.6)\n",
        "    .opt_horizontal_padding(scale=1)\n",
        "    .opt_stylize(style=1)\n",
        "    .tab_style(\n",
        "        style=style.text(weight=\"bold\"), \n",
        "        locations=loc.body(columns=\"Year\")\n",
        "    )\n",
        "    .tab_header(\n",
        "        title=md(\"Six Wind Turbines - Model Senvion MM92\"),\n",
        "        subtitle=md(\"Reliability Evaluation (2016 - 2022)\")\n",
        "    )\n",
        "    .tab_source_note(source_note=\"* Forced Outages (IEC) only. Yearly evaluation period -> Censored uptime (TTF) data around year change.\")    \n",
        "    .fmt_number(\n",
        "        columns=[\"MTTF\", \"MTTR\", \"Downtime\", \"Uptime\", \"EvalTime\"],\n",
        "        decimals=2\n",
        "    )\n",
        "    .fmt_image(\n",
        "        columns=\"icon\",\n",
        "        path=\"./online_assets/\"\n",
        "    )\n",
        "    .fmt_number(\n",
        "        columns=[\"Failure Rate\", \"FOR\", \"Availability\"],\n",
        "        decimals=5\n",
        "    )\n",
        "    .fmt_nanoplot(\n",
        "        columns=\"Monthly\",\n",
        "        plot_type=\"bar\"\n",
        "    )\n",
        "    .tab_spanner(\n",
        "        label=\"Probabilities\",\n",
        "        columns=[\"FOR\", \"Availability\"]\n",
        "    )\n",
        "    .tab_spanner(\n",
        "        label=\"Out-of-Service [h]\",\n",
        "        columns=[\"Downtime\", \"MTTR\"]\n",
        "    )\n",
        "    .tab_spanner(\n",
        "        label=\"*Ready [h]\",\n",
        "        columns=[\"Uptime\", \"MTTF\"]\n",
        "    )\n",
        "    .tab_spanner(\n",
        "        label=\"Forced Outages\",\n",
        "        columns=[\"Forced Outages\", \"Monthly\", \"Failure Rate\"]\n",
        "    )\n",
        "    .cols_move_to_start(\n",
        "        columns=[\"Year\", \"icon\", \"Turbine\", \"Forced Outages\", \"Monthly\", \"Failure Rate\", \"Uptime\",  \"MTTF\"]\n",
        "    )\n",
        "    .cols_label(        \n",
        "        {\"Forced Outages\": \"Total\",         \n",
        "        \"Failure Rate\": \"λ [h⁻¹]\",               \n",
        "        \"icon\": \"Turbine\",\n",
        "        \"FOR\": \"FOR ({{P_0}})\",\n",
        "        \"Availability\": \"A ({{P_1}})\"\n",
        "        }\n",
        "    ).cols_hide(columns=\"EvalTime\")\n",
        ")"
      ],
      "id": "generate-table",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Reliability Parameters\n"
      ],
      "id": "a41be84a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: print-great-table\n",
        "\n",
        "gt_reliability"
      ],
      "id": "print-great-table",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Time / State Diagrams\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "## 2016\n"
      ],
      "id": "e012fbca"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[0].show()"
      ],
      "id": "2ae6cc44",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2017\n"
      ],
      "id": "0214f39b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[1].show()"
      ],
      "id": "abf822f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2018\n"
      ],
      "id": "95de654b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[2].show()"
      ],
      "id": "bee78954",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2019\n"
      ],
      "id": "bfea50b3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[3].show()"
      ],
      "id": "539cb4d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2020\n"
      ],
      "id": "8502ab86"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[4].show()"
      ],
      "id": "3888c7e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2021\n"
      ],
      "id": "51b5e81d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[5].show()"
      ],
      "id": "1fc562b2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2022\n"
      ],
      "id": "44221d8b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pl_time_state[6].show()"
      ],
      "id": "63938d0a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Histogram of Failure Causes\n",
        "\n",
        "### Total\n"
      ],
      "id": "2b2f819e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: failure-hist\n",
        "#| eval: true\n",
        "\n",
        "import plotly.express as px\n",
        "\n",
        "# Count the frequency of each Message\n",
        "message_counts = ttr.group_by(\"Message\").agg(\n",
        "    pl.len().alias(\"Count\")\n",
        ").sort(\"Count\", descending=True)\n",
        "\n",
        "# Create the horizontal bar plot\n",
        "fig = px.bar(\n",
        "    message_counts,\n",
        "    x=\"Count\",\n",
        "    y=\"Message\",\n",
        "    hover_data=\"Count\",\n",
        "    orientation='h',  # Makes the bars horizontal    \n",
        "    labels={\"Message\": \"\", \"Count\": \"Frequency\"},\n",
        ")\n",
        "\n",
        "# Update layout for better readability\n",
        "fig.update_layout(\n",
        "    height=1000,  # Increased height to accommodate all labels\n",
        "    width=770,\n",
        "    yaxis={'categoryorder':'total ascending',\n",
        "           'tickangle': 0  # Make y-axis labels horizontal\n",
        "    },  # Sort bars by count\n",
        "    bargap=0.3 \n",
        ")\n",
        "fig.update_annotations(font_size=8)\n",
        "# fig.update_traces(textposition='outside')\n",
        "# fig.for_each_annotation(textangle=0)  # labels horizontal\n",
        "\n",
        "fig.show()"
      ],
      "id": "failure-hist",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Per Wind Turbine\n"
      ],
      "id": "28e166b3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: histrogram-per-turbine\n",
        "#| eval: true\n",
        "\n",
        "# Count the frequency of each Message per Turbine\n",
        "message_counts_per_wt = ttr.group_by([\"Turbine\", \"Message\"]).agg(\n",
        "    pl.len().alias(\"Count\")\n",
        ").sort([\"Turbine\", \"Count\"], descending=[False, True])\n",
        "\n",
        "# Create the horizontal bar plot with facets\n",
        "fig_2 = px.bar(\n",
        "    message_counts_per_wt,\n",
        "    x=\"Count\",\n",
        "    y=\"Message\",\n",
        "    hover_data=\"Count\",\n",
        "    facet_col=\"Turbine\",  # Create separate plots per turbine\n",
        "    orientation='h',    \n",
        "    labels={\"Message\": \"\", \"Count\": \"Freq.\", \"Turbine\": \"\"},\n",
        ")\n",
        "\n",
        "# Update layout for better readability\n",
        "fig_2.update_layout(\n",
        "    height=1000,\n",
        "    width=770,  # Increased width to accommodate facets\n",
        "    yaxis={'categoryorder':'total ascending',\n",
        "           'tickangle': 0  # Make y-axis labels horizontal\n",
        "    },\n",
        "    bargap=0.2,\n",
        "    showlegend=False\n",
        ")\n",
        "fig.update_annotations(font_size=8)\n",
        "# Update facet settings\n",
        "fig_2.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1]))  # Remove \"Turbine=\" from facet titles\n",
        "\n",
        "fig_2.show()"
      ],
      "id": "histrogram-per-turbine",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}