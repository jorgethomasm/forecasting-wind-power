---
title: "Windpark Kelmarsh (2016) - 12.5 MW"
subtitle: Data Analysis
author: "Jorge A. Thomas"
format: html
jupyter: python3
---

## Data Analysis an Testing Great Tables

Infor available here: 

- https://energymap.co.uk/project.asp?pageid=2948

- https://www.gem.wiki/Kelmarsh_wind_farm

```{python}
#| label: init
#| eval: true
#| echo: false

from pathlib import Path
import duckdb
import polars as pl
import polars.selectors as cs
import plotly.express as px
from great_tables import GT, md

PROJECT_ROOT = Path(__file__).parent.parent.parent.parent
folder_path_interim = PROJECT_ROOT / "data" / "interim"
```

Read parquet files

```{python}

tstatus = pl.read_parquet(f"{folder_path_interim}/Kelmarsh_Turbines_Status_20160114_20230109_n385133_cols12.parquet")

duckdb.sql("DESCRIBE tstatus").show()
```

Filter Stop

```{python}
#| label: Filter Stops

stops = pl.sql(    
    """
    SELECT * EXCLUDE ("Custom contract category")    
    FROM tstatus
    WHERE "Status" = 'Stop'
    """).collect()
```

Filter Forced Outages

```{python}
#| label: Filter Forced Outages
# Aggregate tables using SQL syntax

foutages = pl.sql(
    """
    SELECT * 
    FROM stops
    WHERE "IEC category" = 'Forced outage' 
    """).collect()

foutages = foutages.rename({"Duration":"TTR"})

# TTF
foutages = foutages.with_columns(
    (pl.col("Timestamp start").shift(-1) - pl.col("Timestamp end")).shift(1).alias("TTF")
    )

foutages = foutages.with_columns(
    pl.when(pl.col("TTF") < 0).then(None).otherwise(pl.col("TTF")).alias("TTF")
)

foutages.describe
```

## Time Series for Binary Plot

```{python}
#| label: Binary Plot

dtstarts = foutages.select(["Timestamp start", "Status", "Message",  "wt"]).rename({"Timestamp start": "Timestamp"})
dtends = foutages.select(["Timestamp end", "Status", "Message",  "wt"]).with_columns(pl.lit("Start").alias("Status")).rename({"Timestamp end": "Timestamp"})

tstates = pl.concat([dtstarts, dtends]).sort(["wt", 'Timestamp'])

# tstates_ts = dtstarts.join(dtends, on="Timestamp", how="full").sort(["wt", 'Timestamp'])

tstates= tstates.with_columns(
    pl.when(pl.col("Status") == "Stop").then(0).otherwise(1).alias("State"))

tstates

```

## Plot Square Signal

```{python}
#| label: Square Signal Plot

import plotly.express as px

# # Create a square signal plot for each turbine (wt)
# fig = px.step(
#     tstates,
#     x="Timestamp",
#     y="State",
#     color="wt",
#     title="Square Signal Plot per Turbine",
#     labels={"Timestamp": "Time", "State": "State (0=Stop, 1=Start)", "wt": "Turbine"}
# )

# # Update layout for better visualization
# fig.update_layout(
#     xaxis_title="Timestamp",
#     yaxis_title="State",
#     legend_title="Turbine",
#     template="plotly_white"
# )

# # Show the plot
# fig.show()

import plotly.graph_objects as go

# Create a step-like plot for each turbine (wt)
fig = go.Figure()

# Group data by turbine (wt) and add traces for each turbine
for turbine, group in tstates.group_by("wt"):
    fig.add_trace(
        go.Scatter(
            x=group["Timestamp"],
            y=group["State"],
            mode="lines",
            name=f"Turbine {turbine}",
            line_shape="hv"  # Horizontal-vertical step plot
        )
    )

# Update layout for better visualization
fig.update_layout(
    title="Square Signal Plot per Turbine",
    xaxis_title="Timestamp",
    yaxis_title="State (0=Stop, 1=Start)",
    legend_title="Turbine",
    template="plotly_white"
)

# Show the plot
fig.show()

```

Add Time Between Failure (TBF) and Time To Failure (TTF)

```{python}
#| label: forced outages

foutages_agg_year = (
    foutages.group_by("wt",
                pl.col("Timestamp start").dt.year().alias("Year"))
    .agg(
        pl.len().alias("Total Forced Outages (IEC)"),
        pl.sum("TTF").alias("Total TTF"),        
        pl.sum("TTR").alias("Total TTR"),
        pl.mean("TTR").alias("MTTR"),
        pl.mean("TTF").alias("MTTF")                
        )
    .rename({"wt": "Turbine"})
    .sort("Turbine", "Year") 
    .with_columns(
        (pl.col("MTTR").dt.total_seconds()/3_600 + pl.col("MTTF").dt.total_seconds()/3_600).alias("MTBF"),
        #(pl.col("MTTR").dt.total_hours() + pl.col("MTTF").dt.total_hours()).alias("MTBF hours"),
        #(1/pl.col("MTTF").dt.total_hours()).alias("FOR hours"),
        (1/(pl.col("MTTF").dt.total_seconds()/3_600)).alias("Failure Rate")
        )
    )

foutages_yearly_h = foutages_agg_year.with_columns(    
    pl.col("Total TTR").dt.total_seconds()/3_600,
    pl.col("MTTR").dt.total_seconds()/3_600,
    pl.col("MTTF").dt.total_seconds()/3_600
)

foutages_yearly_h

```
